import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import lognorm, norm
from scipy.optimize import curve_fit
from scipy.stats import chi2

# Carico i dati di "Swift_PCWT.txt"
data = np.loadtxt('Swift_PCWT.txt', comments='!', delimiter='\t')
x = data[:, 0]
y = data[:, 3]
err_y = data[:, 4] * 2

# Filtra i dati in base a val/err
mask = y / err_y >= 3  # Cambiato il criterio di selezione
x = x[mask]
y = y[mask]
err_y = err_y[mask]

# Creo l'istogramma per i dati di Swift
fig, ax = plt.subplots(1, 1, sharex=True, figsize=(8, 6))
hist, bin_edges, patches = ax.hist(y, bins=30, color='crimson', alpha=0.6, edgecolor='black', label='Data')
ax.set_xlabel('Values (Hz)', fontsize = 18)
ax.set_ylabel('Counts', fontsize = 18)
ax.set_title('PG 1553+113 Swift-XRT Histogram', fontsize = 20)

# Calcolo e plotto i centroidi
bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
ax.scatter(bin_centers, hist, color='black', marker='o', label='Bin Centers')

# Fit dei dati con la funzione log-normale
def lognorm_fit(x, A, mu, sigma):
    return A * lognorm.pdf(x, sigma, loc=0, scale=np.exp(mu))

# Non so il motivo ma mettendo determinati p0 il fit viene e viene sempre uguale
p0 = [1, 5, 3]

# Eseguo il fit ed estraggo i parametri stimati
params, _ = curve_fit(lognorm_fit, bin_centers, hist, p0=p0)
A_fit, mu_fit, sigma_fit = params
print(mu_fit, sigma_fit)

# Calcolo il valore dei parametri secondo la distribuzione log-normale e printo
mu_fin = np.exp(mu_fit + 0.5 * sigma_fit ** 2)
sigma_fin = np.sqrt(np.exp(2 * mu_fit + sigma_fit ** 2) * (np.exp(sigma_fit ** 2) - 1))
print("Parametri del fit log-normale (A, mu, sigma):", mu_fin, sigma_fin)

# Creo una curva log-normale con i parametri del fit e la plotto sull'istogramma
x = np.linspace(min(bin_centers), max(bin_centers), 1000)
fit_y = lognorm_fit(x, *params)
ax.plot(x, fit_y, 'r-', label='Log-Normal Fit')

# Calcolo il Chi-quadro osservato
chi_squared = np.sum(((hist - lognorm_fit(bin_centers, *params))** 2 / lognorm_fit(bin_centers, *params)))

# Calcolo i gradi di libert√†
degrees_of_freedom = len(bin_centers) - len(params)

# Calcolo il Chi-quadro ridotto
chi_squared_reduced = chi_squared / degrees_of_freedom

# Calcolo il p-value usando la distribuzione del chi-quadro
p_value = 1 - chi2.cdf(chi_squared, degrees_of_freedom)

# Stampa i risultati
print("Chi-Squared:", chi_squared)
print("Degrees of Freedom:", degrees_of_freedom)
print("Reduced Chi-Squared:", chi_squared_reduced)
print("Chi-Squared Test P-Value (by manual calculation):", p_value)

# Personalizza la dimensione del testo sugli assi
ax.tick_params(axis='both', labelsize=15)

# Mostro tutto
# ax.legend()

plt.tight_layout()
plt.show()
