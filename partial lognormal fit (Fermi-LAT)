import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import lognorm
from scipy.optimize import curve_fit
from scipy.stats import chi2

# Carico i dati dal file "PG1553_with_uppers_3d.txt"
data = np.loadtxt('PG1553_with_uppers_3d.txt', comments='!', delimiter='\t', dtype=object)

# Inizializzo due set: uno per i dati "normali" e uno per gli "upper limits"
data_list = []
uppers_list = []
uppers_count = 0

# Analizzo ogni riga del file distinguendo uppers e dati normali mediante l'uso di "<"
for row in data:
    x, y, err_y = row

    if '<' in y:
        y = y.replace('<', '')
        uppers_list.append([float(x), float(y), float(err_y) if err_y != '-' else 0.0])
        uppers_count += 1
    else:
        data_list.append([float(x), float(y), float(err_y) if err_y != '-' else 0.0])

# Converto le liste in array di numpy e stampo il numero di conteggi di upper limits
data_array = np.array(data_list)
uppers_array = np.array(uppers_list)
print("Numero di upper limits:", uppers_count)

# Creo l'istogramma per i dati normali e con '<'
fig, ax4 = plt.subplots(1, 1, sharex=True, figsize=(8, 6))
bin_edges = np.histogram_bin_edges(data_array[:, 1], bins=30)
hist_data, bin_edges_data, patches_data = ax4.hist(data_array[:, 1], bins=bin_edges, color='violet', edgecolor='black', alpha=0.7, label='Fermi-LAT datas')
hist_uppers, _, _ = ax4.hist(uppers_array[:, 1], bins=bin_edges, color='orange', edgecolor='black', alpha=0.7, label='Upper Limits', bottom=hist_data)

# Calcolo e plotto i centroidi dei dati
bin_centers_data = (bin_edges_data[:-1] + bin_edges_data[1:]) / 2
ax4.scatter(bin_centers_data, hist_data, color='black', marker='o', label='Bin Centers')

# Togli i primi 3 elementi da hist_data e bin_centers_data
hist_data = hist_data[3:]
bin_centers_data = bin_centers_data[3:]

# Togli l'ultimo bin per il calcolo del fit
bin_centers_data = bin_centers_data[:-1]
hist_data = hist_data[:-1]

# Faccio il fit dei dati con la funzione log-normale
def lognorm_fit(x, A, mu, sigma):
    return A * lognorm.pdf(x, sigma, loc=0, scale=np.exp(mu))

# Eseguo il fit ed estraggo i parametri stimati
params, _ = curve_fit(lognorm_fit, bin_centers_data, hist_data, p0=[1, 5, 3])
A_fit, mu_fit, sigma_fit = params

# Calcolo il valore dei parametri secondo la distribuzione log-normale e printo
mu_fin = np.exp(mu_fit + 0.5 * sigma_fit ** 2)
sigma_fin = np.sqrt(np.exp(2 * mu_fit + sigma_fit ** 2) * (np.exp(sigma_fit ** 2) - 1))
print("Parametri del fit log-normale (A, mu, sigma):", mu_fin, sigma_fin)

# Creo una curva log-normale con i parametri del fit e la plotto sull'istogramma
x_fit = np.linspace(min(bin_centers_data), max(bin_centers_data), 1000)
fit_y = lognorm_fit(x_fit, *params)
ax4.plot(x_fit, fit_y, 'r-', label='Log-Normal Fit')

# Calcolo il Chi-quadro osservato
chi_squared = np.sum(((hist_data - lognorm_fit(bin_centers_data, *params))** 2 / lognorm_fit(bin_centers_data, *params)))

# Calcolo i gradi di libertÃ 
degrees_of_freedom = len(bin_centers_data) - len(params)

# Calcolo il Chi-quadro ridotto
chi_squared_reduced = chi_squared / degrees_of_freedom

# Calcolo il p-value usando la distribuzione del chi-quadro
p_value = 1 - chi2.cdf(chi_squared, degrees_of_freedom)

# Stampa i risultati
print("Chi-Squared:", chi_squared)
print("Degrees of Freedom:", degrees_of_freedom)
print("Reduced Chi-Squared:", chi_squared_reduced)
print("P-Value (by manual calculation):", p_value)

# Imposta le etichette degli assi e personalizza la dimensione del testo
ax4.set_xlabel('Values (1/cm2/s)', fontsize=18)
ax4.set_ylabel('Counts', fontsize=18)
ax4.set_title('PG1553+113 Fermi-LAT Histogram (partial lognormal fit)', fontsize=20)

# Personalizza la dimensione del testo sugli assi
ax4.tick_params(axis='both', labelsize=15)

# Mostro tutto
plt.tight_layout()
plt.show()

